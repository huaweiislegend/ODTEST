<html lang="zh-CN"><head><meta charset="UTF-8"><style>.nodata  main {width:1000px;margin: auto;}</style></head><body class="nodata " style=""><div class="main_father clearfix d-flex justify-content-center " style="height:100%;"> <div class="container clearfix " id="mainBox"><main><div class="blog-content-box">
<div class="article-header-box">
<div class="article-header">
<div class="article-title-box">
<h1 class="title-article" id="articleContentId">(A卷,100分)- 网上商城优惠活动（Java & JS & Python）</h1>
</div>
</div>
</div>
<div id="blogHuaweiyunAdvert"></div>

        <div id="article_content" class="article_content clearfix">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css">
                <div id="content_views" class="htmledit_views">
                    <h4 id="main-toc">题目描述</h4> 
<p>某网上商场举办优惠活动&#xff0c;发布了满减、打折、无门槛3种优惠券&#xff0c;分别为&#xff1a;</p> 
<ul><li>每满100元优惠10元&#xff0c;无使用数限制&#xff0c;如100~199元可以使用1张减10元&#xff0c;200~299可使用2张减20元&#xff0c;以此类推&#xff1b;</li><li>92折券&#xff0c;1次限使用1张&#xff0c;如100元&#xff0c;则优惠后为92元&#xff1b;</li><li>无门槛5元优惠券&#xff0c;无使用数限制&#xff0c;直接减5元。</li></ul> 
<p>优惠券使用限制</p> 
<ul><li>每次最多使用2种优惠券&#xff0c;2种优惠可以叠加&#xff08;优惠叠加时以优惠后的价格计算&#xff09;&#xff0c;以购物200元为例&#xff0c;可以先用92折券优惠到184元&#xff0c;再用1张满减券优惠10元&#xff0c;最终价格是174元&#xff0c;也可以用满减券2张优惠20元为180元&#xff0c;再使用92折券优惠到165&#xff08;165.6向下取整&#xff09;&#xff0c;不同使用顺序的优惠价格不同&#xff0c;以最优惠价格为准。在一次购物种&#xff0c;同一类型优惠券使用多张时必须一次性使用&#xff0c;不能分多次拆开使用&#xff08;不允许先使用1张满减券&#xff0c;再用打折券&#xff0c;再使用一张满减券&#xff09;。</li></ul> 
<p>问题</p> 
<ul><li>请设计实现一种解决方法&#xff0c;帮助购物者以最少的优惠券获得最优的优惠价格。优惠后价格越低越好&#xff0c;同等优惠价格&#xff0c;使用的优惠券越少越好&#xff0c;可以允许某次购物不使用优惠券。</li></ul> 
<p>约定</p> 
<ul><li>优惠活动每人只能参加一次&#xff0c;每个人的优惠券种类和数量是一样的。</li></ul> 
<p></p> 
<h4 id="%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0">输入描述</h4> 
<ul><li>第一行&#xff1a;每个人拥有的优惠券数量&#xff08;数量取值范围为[0,10]&#xff09;&#xff0c;按满减、打折、无门槛的顺序输入</li><li>第二行&#xff1a;表示购物的人数n&#xff08;1 ≤ n ≤ 10000&#xff09;</li><li>最后n行&#xff1a;每一行表示某个人优惠前的购物总价格&#xff08;价格取值范围(0, 1000] &#xff0c;都为整数&#xff09;。</li><li>约定&#xff1a;输入都是符合题目设定的要求的。</li></ul> 
<p></p> 
<h4 id="%E8%BE%93%E5%87%BA%E6%8F%8F%E8%BF%B0">输出描述</h4> 
<ul><li>每行输出每个人每次购物优惠后的最低价格以及使用的优惠券总数量</li><li>每行的输出顺序和输入的顺序保持一致</li></ul> 
<p></p> 
<h4>备注</h4> 
<ol><li>优惠券数量都为整数&#xff0c;取值范围为[0, 10]</li><li>购物人数为整数&#xff0c;取值范围为[1, 10000]</li><li>优惠券的购物总价为整数&#xff0c;取值范围为 (0, 1000]</li><li>优惠后价格如果是小数&#xff0c;则向下取整&#xff0c;输出都为整数。</li></ol> 
<p></p> 
<h4 id="%E7%94%A8%E4%BE%8B">用例</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:630px;"><tbody><tr><td style="width:86px;">输入</td><td style="width:540px;">3 2 5<br /> 3<br /> 100<br /> 200<br /> 400</td></tr><tr><td style="width:86px;">输出</td><td style="width:540px;">65 6<br /> 155 7<br /> 338 4</td></tr><tr><td style="width:86px;">说明</td><td style="width:540px;"> <p>输入&#xff1a;</p> 
    <ul><li>第一行&#xff1a;3种优惠券数量分别为&#xff1a;满减券3张&#xff0c;打折券2张&#xff0c;无门槛5张</li><li>第二行&#xff1a;总共3个人购物</li><li>第三行&#xff1a;第一个人购物优惠前价格为100元</li><li>第四行&#xff1a;第二个人购物优惠前价格为200元</li><li>第五行&#xff1a;第三个人购物优惠前价格为400元</li></ul><p>输入3个人&#xff0c;输出3行结果&#xff0c;同输入的顺序&#xff0c;对应每个人的优惠结果&#xff0c;如下&#xff1a;</p> 
    <ul><li>第一行输出&#xff1a;先使用1张满减券优惠到90元&#xff0c;再使用5张无门槛券优惠到25元&#xff0c;最终价格是65元&#xff0c;总共使用6张优惠券。</li><li>第二行输出&#xff1a;先使用2张满减券优惠到180元&#xff0c;再使用5张无门槛券优惠到25元&#xff0c;最终价格是155元&#xff0c;总共使用7张优惠券。</li><li>第三行输出&#xff1a;先使用1张92折券优惠到368元&#xff0c;再使用3张满减券优惠到30元&#xff0c;最终价格是338元&#xff0c;总共使用4张优惠券。</li></ul></td></tr></tbody></table> 
<p></p> 
<h4 id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</h4> 
<p>本题和<a href="https://fcqian.blog.csdn.net/article/details/128156698" rel="nofollow" title="华为OD机试 - 模拟商场优惠打折_伏城之外的博客-CSDN博客">华为OD机试 - 模拟商场优惠打折_伏城之外的博客-CSDN博客</a></p> 
<p>非常类似&#xff0c;但是关于满减券的使用逻辑不同&#xff0c;导致最终实现也不同。本题和上面链接题目应该属于AB卷题目&#xff0c;防止作弊的。</p> 
<p></p> 
<p>模拟商场优惠打折&#xff0c;这题关于满减券的使用逻辑&#xff1a;</p> 
<p><img alt="" height="180" src="https://img-blog.csdnimg.cn/19ea9b6f59a5428d8a53b13bf83cf3bf.png" width="733" /></p> 
<p>即只要符合满减要求&#xff0c;就可以满减&#xff0c;直到满减券用完&#xff0c;比如其用例中 </p> 
<p></p> 
<p>而本题中&#xff0c;满减券使用是有限制的</p> 
<p><img alt="" height="209" src="https://img-blog.csdnimg.cn/db1f96340f924d2ea2f2adf78d3e07b5.png" width="748" /></p> 
<p> 即&#xff1a;满100&#xff0c;最多使用1张减10元的券&#xff0c;满200最多使用2张减10元的券&#xff0c;满300可以使用3张减10元的券....</p> 
<p></p> 
<p>因此&#xff0c;我们只要基于<a href="https://fcqian.blog.csdn.net/article/details/128156698" rel="nofollow" title="华为OD机试 - 模拟商场优惠打折_伏城之外的博客-CSDN博客">华为OD机试 - 模拟商场优惠打折_伏城之外的博客-CSDN博客</a></p> 
<p>中满减的逻辑微调即可。</p> 
<p></p> 
<h4 id="%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81">JavaScript算法源码</h4> 
<pre><code class="language-javascript">/* JavaScript Node ACM模式 控制台输入获取 */
const readline &#61; require(&#34;readline&#34;);

const rl &#61; readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const lines &#61; [];
let m, n, k, x;
rl.on(&#34;line&#34;, (line) &#61;&gt; {
  lines.push(line);

  if (lines.length &#61;&#61;&#61; 1) {
    [m, n, k] &#61; lines[0].split(&#34; &#34;).map(Number);
  }

  if (lines.length &#61;&#61;&#61; 2) {
    x &#61; parseInt(lines[1]);
  }

  if (x &amp;&amp; lines.length &#61;&#61;&#61; x &#43; 2) {
    lines.shift();
    lines.shift();

    const arr &#61; lines.map(Number);

    getResult(arr, m, n, k);

    lines.length &#61; 0;
  }
});

/**
 *
 * &#64;param {*} prices 几个人打折之前的商品总价
 * &#64;param {*} m 满减券数量
 * &#64;param {*} n 打折券数量
 * &#64;param {*} k 无门槛券数量
 */
function getResult(prices, m, n, k) {
  for (let price of prices) {
    const ans &#61; [];

    const resM &#61; M(price, m); // 先满减

    const resMN_N &#61; N(resM[0], n); // 满减后打折
    ans.push([resMN_N[0], m &#43; n - (resM[1] &#43; resMN_N[1])]); // resMN_N[0]是 “满减后打折” 的剩余总价&#xff0c; m &#43; n - resM[1] - resMN_N[1] 是 该种用券方式的: 总券数 m&#43;n&#xff0c; 剩余券数 resM[1] &#43; resMN_N[1], 因此使用掉的券数&#xff1a; m&#43;n - (resM[1] &#43; resMN_N[1])

    const resMK_K &#61; K(resM[0], k); // 满减后无门槛
    ans.push([resMK_K[0], m &#43; k - (resM[1] &#43; resMK_K[1])]);

    const resN &#61; N(price, n); // 先打折

    const resNM_M &#61; M(resN[0], m); // 打折后满减
    ans.push([resNM_M[0], n &#43; m - (resN[1] &#43; resNM_M[1])]);

    const resNK_K &#61; K(resN[0], k); // 打折后无门槛
    ans.push([resNK_K[0], n &#43; k - (resN[1] &#43; resNK_K[1])]);

    ans.sort((a, b) &#61;&gt; (a[0] &#61;&#61;&#61; b[0] ? a[1] - b[1] : a[0] - b[0])); // 对ans进行排序&#xff0c;排序规则是&#xff1a;优先按剩余总价升序&#xff0c;如果剩余总价相同&#xff0c;则再按“使用掉的券数量”升序

    console.log(ans[0].join(&#34; &#34;));
  }
}

/**
 * &#64;param {*} price 总价
 * &#64;param {*} m 满减券数量
 * &#64;returns 总价满减后结果&#xff0c;对应数组含义是 [用券后剩余总价&#xff0c; 剩余满减券数量]
 */
function M(price, m) {
  const maxCount &#61; Math.floor(price / 100); // 满100最多用1张满减券&#xff0c;满200最多用2张满减券....&#xff0c;price总价最多使用price/100张券
  const count &#61; Math.min(m, maxCount); // 实际可使用的满减券数量

  price -&#61; count * 10;
  m -&#61; count;

  return [price, m];
}

/**
 * &#64;param {*} price 总价
 * &#64;param {*} n 打折券数量
 * &#64;returns 总价打折后结果&#xff0c;对应数组含义是 [用券后剩余总价&#xff0c; 剩余打折券数量]
 */
function N(price, n) {
  if (n &gt;&#61; 1) {
    price &#61; Math.floor(price * 0.92);
  }
  return [price, n - 1];
}

/**
 * &#64;param {*} price 总价
 * &#64;param {*} k 无门槛券数量
 * &#64;returns 无门槛券用后结果&#xff0c;对应数组含义是 [用券后剩余总价&#xff0c; 剩余无门槛券数量]
 */
function K(price, k) {
  while (price &gt; 0 &amp;&amp; k &gt; 0) {
    price -&#61; 5;
    price &#61; Math.max(price, 0); // 无门槛券过多会导致优惠后总价小于0&#xff0c;此时我们应该避免
    k--;
  }
  return [price, k];
}
</code></pre> 
<p></p> 
<h4>Java算法源码</h4> 
<pre><code class="language-java">import java.util.Arrays;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner sc &#61; new Scanner(System.in);

    int m &#61; sc.nextInt();
    int n &#61; sc.nextInt();
    int k &#61; sc.nextInt();
    int x &#61; sc.nextInt();

    int[] arr &#61; new int[x];
    for (int i &#61; 0; i &lt; x; i&#43;&#43;) {
      arr[i] &#61; sc.nextInt();
    }

    getResult(arr, m, n, k);
  }

  public static void getResult(int[] arr, int m, int n, int k) {
    for (int i &#61; 0; i &lt; arr.length; i&#43;&#43;) {
      Integer[][] ans &#61; new Integer[4][2]; // 4的含义对应4种使用券的方式&#xff1a;MN,NM,MK,NK,  2的含义对应每种方式下&#xff1a;剩余总价&#xff0c;剩余券数量
      int price &#61; arr[i];

      int[] resM &#61; M(price, m); // 先满减
      int[] resN &#61; N(price, n); // 先打折

      // MN
      int[] resMN_N &#61; N(resM[0], n); // 满减后打折
      ans[0] &#61;
          new Integer[] {
            resMN_N[0], m &#43; n - resM[1] - resMN_N[1]
          }; // resMN_N[0]是 “满减后打折” 的剩余总价&#xff0c; m &#43; n - resM[1] - resMN_N[1] 是 该种用券方式的: 总券数 m&#43;n&#xff0c; 剩余券数
      // resM[1] &#43; resMN_N[1], 因此使用掉的券数&#xff1a; m&#43;n - (resM[1] &#43; resMN_N[1])

      // NM
      int[] resNM_M &#61; M(resN[0], m); // 打折后满减
      ans[1] &#61; new Integer[] {resNM_M[0], n &#43; m - resN[1] - resNM_M[1]};

      // MK
      int[] resMK_K &#61; K(resM[0], k); // 满减后无门槛
      ans[2] &#61; new Integer[] {resMK_K[0], m &#43; k - resM[1] - resMK_K[1]};

      // NK
      int[] resNK_K &#61; K(resN[0], k); // 打折后无门槛
      ans[3] &#61; new Integer[] {resNK_K[0], n &#43; k - resN[1] - resNK_K[1]};

      Arrays.sort(
          ans,
          (a, b) -&gt;
              a[0].equals(b[0])
                  ? a[1] - b[1]
                  : a[0] - b[0]); // 对ans进行排序&#xff0c;排序规则是&#xff1a;优先按剩余总价升序&#xff0c;如果剩余总价相同&#xff0c;则再按“使用掉的券数量”升序
      System.out.println(ans[0][0] &#43; &#34; &#34; &#43; ans[0][1]);
    }
  }

  /**
   * &#64;param price 总价
   * &#64;param m 满减券数量
   * &#64;return 总价满减后结果&#xff0c;对应数组含义是 [用券后剩余总价&#xff0c; 剩余满减券数量]
   */
  public static int[] M(int price, int m) {
    int maxCount &#61; price / 100; // 满100最多用1张满减券&#xff0c;满200最多用2张满减券....&#xff0c;price总价最多使用price/100张券
    int count &#61; Math.min(maxCount, m); // 实际可使用的满减券数量

    price -&#61; count * 10; // 每张满减券只能减10元
    m -&#61; count;

    return new int[] {price, m};
  }

  /**
   * &#64;param price 总价
   * &#64;param n 打折券数量
   * &#64;return 总价打折后结果&#xff0c;对应数组含义是 [用券后剩余总价&#xff0c; 剩余打折券数量]
   */
  public static int[] N(int price, int n) {
    if (n &gt;&#61; 1) {
      price &#61; (int) Math.floor((price * 0.92));
    }
    return new int[] {price, n - 1};
  }

  /**
   * &#64;param price 总价
   * &#64;param k 无门槛券数量
   * &#64;return 无门槛券用后结果&#xff0c;对应数组含义是 [用券后剩余总价&#xff0c; 剩余无门槛券数量]
   */
  public static int[] K(int price, int k) {
    while (price &gt; 0 &amp;&amp; k &gt; 0) {
      price -&#61; 5;
      price &#61; Math.max(price, 0); // 感谢m0_71826536提供的思路&#xff0c;当无门槛券过多时&#xff0c;是有可能导致优惠后总价低于0的情况的&#xff0c;此时我们应该避免总价小于0的情况
      k--;
    }
    return new int[] {price, k};
  }
}
</code></pre> 
<p></p> 
<h4>Python算法源码</h4> 
<pre><code class="language-python">m, n, k &#61; map(int, input().split())

x &#61; int(input())

prices &#61; []
for i in range(x):
    prices.append(int(input()))


def fullSubtraction(price, m):
    &#34;&#34;&#34;
    满减规则
    :param price: 总价
    :param m: 满减券数量
    :return: 总价满减后结果&#xff0c;对应数组含义是 (用券后剩余总价&#xff0c; 剩余满减券数量)
    &#34;&#34;&#34;
    maxCount &#61; int(price / 100)  # 满100最多用1张满减券&#xff0c;满200最多用2张满减券....&#xff0c;price总价最多使用price/100张券
    count &#61; min(m, maxCount)  # 实际可使用的满减券数量

    price -&#61; count * 10
    m -&#61; count

    return price, m


def discount(price, n):
    &#34;&#34;&#34;
    打折规则
    :param price: 总价
    :param n: 打折券数量
    :return: 总价打折后结果&#xff0c;对应数组含义是 (用券后剩余总价&#xff0c; 剩余打折券数量)
    &#34;&#34;&#34;
    if n &gt;&#61; 1:
        price &#61; int(price * 0.92)
    return price, n - 1


def thresholdFree(price, k):
    &#34;&#34;&#34;
    无门槛你规则
    :param price: 总价
    :param k: 无门槛券数量
    :return: 门槛券用后结果&#xff0c;对应数组含义是 (用券后剩余总价&#xff0c; 剩余无门槛券数量)
    &#34;&#34;&#34;
    while price &gt; 0 and k &gt; 0:
        price -&#61; 5
        price &#61; max(price, 0)  # 无门槛券过多会导致优惠后总价小于0&#xff0c;此时我们应该避免
        k -&#61; 1
    return price, k


for price in prices:
    ans &#61; []

    resM &#61; fullSubtraction(price, m)  # 先满减

    resMN_N &#61; discount(resM[0], n)  # 满减后打折
    ans.append((resMN_N[0], m &#43; n - (resM[1] &#43; resMN_N[1])))  # m &#43; n 是满减后打折方式的总券数量&#xff0c; resM[1] &#43; resMN_N[1] 是满减券剩余数&#43;打折券剩余数

    resMK_K &#61; thresholdFree(resM[0], k)  # 满减后无门槛
    ans.append((resMK_K[0], m &#43; k - (resM[1] &#43; resMK_K[1])))

    resN &#61; discount(price, n)  # 先打折

    resNM_M &#61; fullSubtraction(resN[0], m)  # 打折后满减
    ans.append((resNM_M[0], n &#43; m - (resN[1] &#43; resNM_M[1])))

    resNK_K &#61; thresholdFree(resN[0], k)  # 打折后无门槛
    ans.append((resNK_K[0], n &#43; k - (resN[1] &#43; resNK_K[1])))

    # 对ans进行排序&#xff0c;排序规则是&#xff1a;优先按剩余总价升序&#xff0c;如果剩余总价相同&#xff0c;则再按“使用掉的券数量”升序
    ans.sort(key&#61;lambda x: (x[0], x[1]))

    print(&#34; &#34;.join(map(str, ans[0])))
</code></pre> 
<p></p>
                </div>
        </div>
        <div id="treeSkill"></div>
        <div id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px" class="blog-extension-box"></div>
    <script>
  $(function() {
    setTimeout(function () {
      var mathcodeList = document.querySelectorAll('.htmledit_views img.mathcode');
      if (mathcodeList.length > 0) {
        for (let i = 0; i < mathcodeList.length; i++) {
          if (mathcodeList[i].naturalWidth === 0 || mathcodeList[i].naturalHeight === 0) {
            var alt = mathcodeList[i].alt;
            alt = '\\(' + alt + '\\)';
            var curSpan = $('<span class="img-codecogs"></span>');
            curSpan.text(alt);
            $(mathcodeList[i]).before(curSpan);
            $(mathcodeList[i]).remove();
          }
        }
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
      }
    }, 1000)
  });
</script>
</div></html>