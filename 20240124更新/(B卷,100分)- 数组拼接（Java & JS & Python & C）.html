<html lang="zh-CN"><head><meta charset="UTF-8"><style>.nodata  main {width:1000px;margin: auto;}</style></head><body class="nodata " style=""><div class="main_father clearfix d-flex justify-content-center " style="height:100%;"> <div class="container clearfix " id="mainBox"><main><div class="blog-content-box">
<div class="article-header-box">
<div class="article-header">
<div class="article-title-box">
<h1 class="title-article" id="articleContentId">(B卷,100分)- 数组拼接（Java & JS & Python & C）</h1>
</div>
</div>
</div>
<div id="blogHuaweiyunAdvert"></div>

        <div id="article_content" class="article_content clearfix">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css">
                <div id="content_views" class="htmledit_views">
                    <h4 id="main-toc">题目描述</h4> 
<p>现在有多组整数数组&#xff0c;需要将它们合并成一个新的数组。</p> 
<p>合并规则&#xff0c;从每个数组里按顺序取出固定长度的内容合并到新的数组中&#xff0c;取完的内容会删除掉&#xff0c;如果该行不足固定长度或者已经为空&#xff0c;则直接取出剩余部分的内容放到新的数组中&#xff0c;继续下一行。</p> 
<p></p> 
<h4 id="%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0">输入描述</h4> 
<p>第一行是每次读取的固定长度&#xff0c;0 &lt; 长度 &lt; 10</p> 
<p>第二行是整数数组的数目&#xff0c;0 &lt; 数目 &lt; 1000</p> 
<p>第3-n行是需要合并的数组&#xff0c;不同的数组用回车换行分隔&#xff0c;数组内部用逗号分隔&#xff0c;最大不超过100个元素。</p> 
<p></p> 
<h4 id="%E8%BE%93%E5%87%BA%E6%8F%8F%E8%BF%B0">输出描述</h4> 
<p>输出一个新的数组&#xff0c;用逗号分隔。</p> 
<p></p> 
<h4 id="%E7%94%A8%E4%BE%8B">用例</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:86px;">输入</td><td style="width:412px;"> <p>3<br /> 2<br /> 2,5,6,7,9,5,7<br /> 1,7,4,3,4</p> </td></tr><tr><td style="width:86px;">输出</td><td style="width:412px;">2,5,6,1,7,4,7,9,5,3,4,7</td></tr><tr><td style="width:86px;">说明</td><td style="width:412px;">1、获得长度3和数组数目2<br /> 2、先遍历第一行&#xff0c;获得2,5,6<br /> 3、再遍历第二行&#xff0c;获得1,7,4<br /> 4、再循环回到第一行&#xff0c;获得7,9,5<br /> 5、再遍历第二行&#xff0c;获得3,4<br /> 6、再回到第一行&#xff0c;获得7&#xff0c;按顺序拼接成最终结果</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="width:87px;">输入</td><td style="width:411px;">4<br /> 3<br /> 1,2,3,4,5,6<br /> 1,2,3<br /> 1,2,3,4</td></tr><tr><td style="width:87px;">输出</td><td style="width:411px;">1,2,3,4,1,2,3,1,2,3,4,5,6</td></tr><tr><td style="width:87px;">说明</td><td style="width:411px;">无</td></tr></tbody></table> 
<p></p> 
<h4 id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</h4> 
<blockquote> 
 <p>&#xff08;C语言解析请直接看代码注释&#xff0c;以下是其他语言解析&#xff09;</p> 
</blockquote> 
<p>假设&#xff0c;第一行输入的固定长度是subLen。</p> 
<p>我的解题思路如下&#xff1a;</p> 
<p>首先&#xff0c;定义一个动态数组ans&#xff0c;来记录题解。</p> 
<p>然后&#xff0c;将输入的3~n行对应的数组&#xff0c;放到一个链表中。</p> 
<p>每次取出链表的头部&#xff0c;然后删除该头部数组前subLen个元素&#xff0c;并这subLen元素记录按顺序录入ans中&#xff1a;</p> 
<ul><li>如果删除后&#xff0c;该头部数组长度依旧大于0&#xff0c;则将该头部数组重新连接到链表尾部</li><li>如果删除后&#xff0c;该头部数组的长度为0&#xff0c;则不做操作</li></ul> 
<p>直到链表长度为0时&#xff0c;停止。</p> 
<p>此时ans中记录的就是题解。</p> 
<p></p> 
<p>本题&#xff0c;主要难点在于&#xff0c;如何删除数组&#xff08;或其他容器&#xff09;的前subLen个元素&#xff0c;其实就是删除容器中某个范围的所有元素。在下面代码中&#xff0c;我针对不同语言&#xff0c;各附带了一个链接&#xff0c;里面有说明如何删除对应容器的某个范围的元素的策略。</p> 
<hr /> 
<p>2023.08.29</p> 
<p>本题根据考友实际考试反馈&#xff0c;机考系统输入用例存在如下&#xff1a;</p> 
<blockquote> 
 <p>3<br /> 2<br /> 2,5,6,7,,,9,5,7<br /> 1,7,4,3,,4</p> 
</blockquote> 
<p><img alt="" height="457" src="https://img-blog.csdnimg.cn/090aa00104b843ca9b081f5a31961243.png" width="908" /></p> 
<p><img alt="" height="447" src="https://img-blog.csdnimg.cn/1503592227c24e47a275f5df8c922392.png" width="904" /></p> 
<p></p> 
<p></p> 
<h4>Java算法源码</h4> 
<p><a href="https://www.kaelli.com/23.html" rel="nofollow" title="List实现高效批量删除指定区域的元素&#xff08;等效于removeRange) | KaelLi的博客">List实现高效批量删除指定区域的元素&#xff08;等效于removeRange) | KaelLi的博客</a></p> 
<pre><code class="language-java">import java.util.*;
import java.util.stream.Collectors;

public class Main {
  public static void main(String[] args) {
    Scanner sc &#61; new Scanner(System.in);

    int subLen &#61; Integer.parseInt(sc.nextLine());

    int n &#61; Integer.parseInt(sc.nextLine());

    LinkedList&lt;LinkedList&lt;Integer&gt;&gt; lists &#61; new LinkedList&lt;&gt;();
    for (int i &#61; 0; i &lt; n; i&#43;&#43;) {
      lists.add(
          new LinkedList&lt;&gt;(
              Arrays.stream(sc.nextLine().split(&#34;,&#34;))
                  // 输入用例中的数组存在 4,,6 这种情况&#xff0c;所以这里需要过滤掉空串
                  .filter(a -&gt; !&#34;&#34;.equals(a))
                  .map(Integer::parseInt)
                  .collect(Collectors.toList())));
    }

    System.out.println(getResult(subLen, lists));
  }

  public static String getResult(int subLen, LinkedList&lt;LinkedList&lt;Integer&gt;&gt; lists) {
    ArrayList&lt;Integer&gt; ans &#61; new ArrayList&lt;&gt;();

    while (lists.size() &gt; 0) {
      LinkedList&lt;Integer&gt; list &#61; lists.removeFirst();
      ans.addAll(removeRange(list, 0, subLen));
      if (list.size() &gt; 0) lists.addLast(list);
    }

    StringJoiner sj &#61; new StringJoiner(&#34;,&#34;);
    for (Integer an : ans) {
      sj.add(an &#43; &#34;&#34;);
    }
    return sj.toString();
  }

  public static List&lt;Integer&gt; removeRange(LinkedList&lt;Integer&gt; list, int start, int end) {
    if (end &gt; list.size()) end &#61; list.size();

    List&lt;Integer&gt; tmp &#61; list.subList(start, end);

    List&lt;Integer&gt; ans &#61; new ArrayList&lt;&gt;(tmp);
    tmp.clear();

    return ans;
  }
}
</code></pre> 
<p></p> 
<h4 id="%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81">JS算法源码</h4> 
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="nofollow" title="Array.prototype.splice() - JavaScript | MDN (mozilla.org)">Array.prototype.splice() - JavaScript | MDN (mozilla.org)</a></p> 
<pre><code class="language-javascript">/* JavaScript Node ACM模式 控制台输入获取 */
const readline &#61; require(&#34;readline&#34;);

const rl &#61; readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const lines &#61; [];
rl.on(&#34;line&#34;, (line) &#61;&gt; {
  lines.push(line);

  if (lines[1] &amp;&amp; lines.length &#61;&#61;&#61; 2 &#43; parseInt(lines[1])) {
    const subLen &#61; lines.shift() - 0;
    lines.shift();
    const lists &#61; lines.map((line) &#61;&gt;
      line
        .split(&#34;,&#34;)
        // 输入用例中的数组存在 4,,6 这种情况&#xff0c;所以这里需要过滤掉空串
        .filter((a) &#61;&gt; a !&#61; &#34;&#34;)
        .map(Number)
    );

    console.log(getResult(subLen, lists));

    lines.length &#61; 0;
  }
});

function getResult(subLen, lists) {
  const ans &#61; [];

  while (lists.length &gt; 0) {
    const list &#61; lists.shift();
    ans.push(...list.splice(0, subLen));
    if (list.length &gt; 0) lists.push(list);
  }

  return ans.join(&#34;,&#34;);
}
</code></pre> 
<p></p> 
<h4>Python算法源码</h4> 
<p><a href="https://blog.csdn.net/weixin_35752122/article/details/129571850" title="python删除列表的指定一段区域_坑货两只的博客-CSDN博客">python删除列表的指定一段区域_坑货两只的博客-CSDN博客</a></p> 
<pre><code class="language-python"># 输入获取
subLen &#61; int(input())
n &#61; int(input())
# 输入用例中的数组存在 4,,6 这种情况&#xff0c;所以这里需要过滤掉空串
lists &#61; [list(filter(lambda x: x !&#61; &#34;&#34;, input().split(&#34;,&#34;))) for _ in range(n)]


# 算法入口
def getResult():
    ans &#61; []

    while len(lists) &gt; 0:
        lst &#61; lists.pop(0)
        tmp &#61; lst[:subLen]
        del lst[:subLen]
        ans.extend(tmp)
        if len(lst) &gt; 0:
            lists.append(lst)

    return &#34;,&#34;.join(ans)


# 算法调用
print(getResult())
</code></pre> 
<p></p> 
<h4>C算法源码</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MIN(a, b) (a) &lt; (b) ? (a) : (b)

// 链表元素类型
typedef int E;

// 链表节点类型
typedef struct ListNode {
    E ele;
    struct ListNode *next;
} Node;

// 链表结构
typedef struct List {
    Node *head;
    Node *tail;
    int size;
} LinkedList;

// 链表函数声明
LinkedList *new_LinkedList();

void addLast_LinkedList(LinkedList *link, E ele);

E removeFirst_LinkedList(LinkedList *link);

LinkedList *parseToLink(char *s, char *delimiter);

char *parseToStr(LinkedList *link, char *delimiter);

// 算法入口
char *getResult(int subLen, LinkedList **links, int links_size);


int main() {
    // 每次读取的固定长度
    int subLen;
    scanf(&#34;%d&#34;, &amp;subLen);

    // 整数数组的数目
    int n;
    scanf(&#34;%d&#34;, &amp;n);

    LinkedList **links &#61; (LinkedList **) malloc(sizeof(LinkedList *) * n);
    for (int i &#61; 0; i &lt; n; i&#43;&#43;) {
        // 需要合并的数组
        char line[10000];
        scanf(&#34;%s&#34;, line);
        // 将输入的每组数列按照“,”分割&#xff0c;存入链表中
        links[i] &#61; parseToLink(line, &#34;,&#34;);
    }

    printf(&#34;%s&#34;, getResult(subLen, links, n));

    return 0;
}

char *getResult(int subLen, LinkedList **links, int links_size) {
    LinkedList *ans &#61; new_LinkedList();

    // 已空的链表个数
    int complete_count &#61; 0;

    // 如果所有链表都空了&#xff0c;则结束循环
    while (complete_count !&#61; links_size) {
        for (int i &#61; 0; i &lt; links_size; i&#43;&#43;) {
            LinkedList *link &#61; links[i];

            // 如果当前链表不为空&#xff0c;但是本轮结束后可以空&#xff0c;则本轮结束后已空的链表个数&#43;1
            if (link-&gt;size !&#61; 0 &amp;&amp; link-&gt;size &lt;&#61; subLen) {
                complete_count&#43;&#43;;
            }

            // 本轮链表需要头删的元素个数
            int size &#61; MIN(subLen, link-&gt;size);
            for (int j &#61; 0; j &lt; size; j&#43;&#43;) {
                addLast_LinkedList(ans, removeFirst_LinkedList(link));
            }
        }
    }

    return parseToStr(ans, &#34;,&#34;);
}

// 指定分隔符的数列字符串 转为 链表
LinkedList *parseToLink(char *s, char *delimiter) {
    LinkedList *link &#61; new_LinkedList();

    char *token &#61; strtok(s, delimiter);
    while (token !&#61; NULL) {
        addLast_LinkedList(link, atoi(token));
        token &#61; strtok(NULL, delimiter);
    }

    return link;
}

// 链表 转为 指定分隔符的数列字符串
char *parseToStr(LinkedList *link, char *delimiter) {
    char *res &#61; (char *) calloc(sizeof(char), link-&gt;size * 10);

    Node *cur &#61; link-&gt;head;
    while (cur !&#61; NULL) {
        char *tmp &#61; (char *) calloc(sizeof(char), 10);
        sprintf(tmp, &#34;%d&#34;, cur-&gt;ele);

        strcat(res, tmp);

        cur &#61; cur-&gt;next;

        if (cur !&#61; NULL) {
            strcat(res, delimiter);
        }
    }

    return res;
}

// 创建和初始化链表
LinkedList *new_LinkedList() {
    LinkedList *link &#61; (LinkedList *) malloc(sizeof(LinkedList));

    link-&gt;head &#61; NULL;
    link-&gt;tail &#61; NULL;
    link-&gt;size &#61; 0;

    return link;
}

// 链表尾插
void addLast_LinkedList(LinkedList *link, E ele) {
    Node *node &#61; (Node *) malloc(sizeof(Node));
    node-&gt;ele &#61; ele;
    node-&gt;next &#61; NULL;

    if (link-&gt;size &#61;&#61; 0) {
        link-&gt;head &#61; node;
        link-&gt;tail &#61; node;
    } else {
        link-&gt;tail-&gt;next &#61; node;
        link-&gt;tail &#61; node;
    }

    link-&gt;size&#43;&#43;;
}

// 链表头删
E removeFirst_LinkedList(LinkedList *link) {
    if (link-&gt;size &gt; 0) {
        Node *removed &#61; link-&gt;head;

        link-&gt;head &#61; link-&gt;head-&gt;next;
        link-&gt;size--;

        E res &#61; removed-&gt;ele;
        free(removed);

        return res;
    } else {
        exit(-1);
    }
}

</code></pre>
                </div>
        </div>
        <div id="treeSkill"></div>
        <div id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px" class="blog-extension-box"></div>
    <script>
  $(function() {
    setTimeout(function () {
      var mathcodeList = document.querySelectorAll('.htmledit_views img.mathcode');
      if (mathcodeList.length > 0) {
        for (let i = 0; i < mathcodeList.length; i++) {
          if (mathcodeList[i].naturalWidth === 0 || mathcodeList[i].naturalHeight === 0) {
            var alt = mathcodeList[i].alt;
            alt = '\\(' + alt + '\\)';
            var curSpan = $('<span class="img-codecogs"></span>');
            curSpan.text(alt);
            $(mathcodeList[i]).before(curSpan);
            $(mathcodeList[i]).remove();
          }
        }
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
      }
    }, 1000)
  });
</script>
</div></html>