<html lang="zh-CN"><head><meta charset="UTF-8"><style>.nodata  main {width:1000px;margin: auto;}</style></head><body class="nodata " style=""><div class="main_father clearfix d-flex justify-content-center " style="height:100%;"> <div class="container clearfix " id="mainBox"><main><div class="blog-content-box">
<div class="article-header-box">
<div class="article-header">
<div class="article-title-box">
<h1 class="title-article" id="articleContentId">(C卷,100分)- 螺旋数字矩阵（Java & JS & Python & C）</h1>
</div>
</div>
</div>
<div id="blogHuaweiyunAdvert"></div>

        <div id="article_content" class="article_content clearfix">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/kdoc_html_views-1a98987dfd.css">
        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-044f2cf1dc.css">
                <div id="content_views" class="htmledit_views">
                    <h4 id="main-toc">题目描述</h4> 
<p>疫情期间&#xff0c;小明隔离在家&#xff0c;百无聊赖&#xff0c;在纸上写数字玩。他发明了一种写法&#xff1a;</p> 
<p>给出数字个数 n &#xff08;0 &lt; n ≤ 999&#xff09;和行数 m&#xff08;0 &lt; m ≤ 999&#xff09;&#xff0c;从左上角的 1 开始&#xff0c;按照顺时针螺旋向内写方式&#xff0c;依次写出2,3,....,n&#xff0c;最终形成一个 m 行矩阵。</p> 
<p>小明对这个矩阵有些要求&#xff1a;</p> 
<ol><li>每行数字的个数一样多</li><li>列的数量尽可能少</li><li>填充数字时优先填充外部</li><li>数字不够时&#xff0c;使用单个 * 号占位</li></ol> 
<p></p> 
<h4 id="%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0">输入描述</h4> 
<p>两个整数&#xff0c;空格隔开&#xff0c;依次表示 n、m</p> 
<p></p> 
<h4 id="%E8%BE%93%E5%87%BA%E6%8F%8F%E8%BF%B0">输出描述</h4> 
<p>符合要求的唯一矩阵</p> 
<p></p> 
<h4 id="%E7%94%A8%E4%BE%8B">用例</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:65px;">输入</td><td style="width:533px;">9 4</td></tr><tr><td style="width:65px;">输出</td><td style="width:533px;">1 2 3<br /> * * 4<br /> 9 * 5<br /> 8 7 6</td></tr><tr><td style="width:65px;">说明</td><td style="width:533px;">9个数字写出4行&#xff0c;最少需要3列</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:63px;">输入</td><td style="width:535px;">3 5</td></tr><tr><td style="width:63px;">输出</td><td style="width:535px;"> <p>1</p> <p>2</p> <p>3</p> <p>*</p> <p>*</p> </td></tr><tr><td style="width:63px;">说明</td><td style="width:535px;">3个数字写5行&#xff0c;只有一列&#xff0c;数字不够用*号填充</td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:62px;">输入</td><td style="width:536px;">120 7</td></tr><tr><td style="width:62px;">输出</td><td style="width:536px;">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18<br /> 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 19<br /> 45 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 63 20<br /> 44 83 114 115 116 117 118 119 120 * * * * * * 99 64 21<br /> 43 82 113 112 111 110 109 108 107 106 105 104 103 102 101 100 65 22<br /> 42 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 23<br /> 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24</td></tr><tr><td style="width:62px;">说明</td><td style="width:536px;">无</td></tr></tbody></table> 
<p></p> 
<h4 id="%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">题目解析</h4> 
<p>本题需要我们将1~n数字按照螺旋顺序填入矩阵。</p> 
<p>本题只给出了矩阵的行数m&#xff0c;没有给列数&#xff0c;需要我们求解一个最少的列数来满足矩阵能够填入n个数字&#xff0c;因此列数 k &#61; ceil(n / m)&#xff0c;这里的除法不是整除&#xff0c;并且要对除法的结果向上取整。</p> 
<p></p> 
<p>将数字1~n按照螺旋顺序&#xff0c;从矩阵matrix左上角开始填入&#xff0c;比较考察思维能力&#xff0c;具体实现如下&#xff1a;</p> 
<ul><li>定义变量step&#xff0c;初始step&#61;1&#xff0c;表示当前要填入的数字&#xff0c;因此step ≤ n</li><li>定义变量x&#xff0c;y&#xff0c;初始x&#61;0, y&#61;0&#xff0c;表示要填值得矩阵位置&#xff0c;即初始时从矩阵左上角开始填入</li></ul> 
<p>然后按照顺序循环进行下面四个填值操作&#xff1a;</p> 
<ol><li>正序填入第X行</li><li>正序填入第Y列</li><li>倒序填入第X行</li><li>倒序填入第Y列</li></ol> 
<p><img alt="" height="363" src="https://img-blog.csdnimg.cn/direct/1c5b97a402864798bd525254bdf448dd.png" width="568" /></p> 
<p></p> 
<p>具体行为如下&#xff1a;</p> 
<h5>正序填入第x行</h5> 
<p>初始时&#xff0c;X,Y处于下面位置</p> 
<p><img alt="" height="295" src="https://img-blog.csdnimg.cn/direct/5a8a63d4be684595811fa824b8929e1f.png" width="339" /></p> 
<p>按照螺旋顺序&#xff0c;我们应该正序填第X行&#xff0c;即此时行号X不变&#xff0c;列号Y&#43;&#43;&#xff0c;具体操作是&#xff1a;</p> 
<blockquote> 
 <p>matrix[x][y&#43;&#43;] &#61; step&#43;&#43;</p> 
</blockquote> 
<p>当列号 Y &gt;&#61; k 时停止填值。如下图所示&#xff1a;此时 X &#61; 0&#xff0c;Y &#61; k</p> 
<p><img alt="" height="252" src="https://img-blog.csdnimg.cn/direct/fbc19e37a1bc4290bd884767cc2bc903.png" width="335" /></p> 
<h5>正序填入第y列</h5> 
<p>按照螺旋顺序&#xff0c;下一步我们应该做一次X&#43;&#43;, Y--&#xff0c;让填值位置移动到&#xff08;X,Y&#xff09;位置</p> 
<p><img alt="" height="280" src="https://img-blog.csdnimg.cn/direct/7018415dda284c44818b7bf8b5fe3d6b.png" width="268" /></p> 
<p>开始正序填第Y列&#xff0c;即此时列号Y保持不变&#xff0c;行号X&#43;&#43;&#xff0c;具体操作是&#xff1a;</p> 
<blockquote> 
 <p>matrix[x&#43;&#43;][y] &#61; step&#43;&#43;</p> 
</blockquote> 
<p>当行号X &gt;&#61; m 时停止填值。如下图所示&#xff1a;此时X&#61;n&#xff0c;Y &#61; k - 1</p> 
<p><img alt="" height="340" src="https://img-blog.csdnimg.cn/direct/afb7e9bd85b24986a775407d1dbf82b7.png" width="314" /></p> 
<p></p> 
<h5>倒序填入第x行</h5> 
<p>按照螺旋顺序&#xff0c;下一步我们应该做一次X--, Y--&#xff0c;让填值位置移动到&#xff08;X,Y&#xff09;位置</p> 
<p><img alt="" height="302" src="https://img-blog.csdnimg.cn/direct/37042aaa8dc64be981a732898e67406c.png" width="267" /></p> 
<p>开始倒序填第X行&#xff0c;即此时行号X保持不变&#xff0c;列号Y--&#xff0c;具体操作是&#xff1a;</p> 
<blockquote> 
 <p>matrix[x][y--] &#61; step&#43;&#43;</p> 
</blockquote> 
<p>当行号Y &lt; 0 时停止填值。如下图所示&#xff1a;此时 X&#61;n-1&#xff0c;Y &#61; -1</p> 
<p><img alt="" height="289" src="https://img-blog.csdnimg.cn/direct/d3f1302ee337456ab0c010fee80e88c8.png" width="286" /></p> 
<p></p> 
<h5>倒序填入第y列</h5> 
<p>按照螺旋顺序&#xff0c;下一步我们应该做一次X--, Y&#43;&#43;&#xff0c;让填值位置移动到&#xff08;X,Y&#xff09;位置</p> 
<p><img alt="" height="302" src="https://img-blog.csdnimg.cn/direct/d040cd8ad76d4bc7a262010417a78576.png" width="274" /></p> 
<p>开始倒序填第Y列&#xff0c;即此时行号X--&#xff0c;列号Y保持不变&#xff0c;具体操作是&#xff1a;</p> 
<blockquote> 
 <p>matrix[x--][y] &#61; step&#43;&#43;</p> 
</blockquote> 
<p>当行号X &lt; 0 时停止填值。如下图所示&#xff1a;此时 X&#61;-1&#xff0c;Y &#61; 0</p> 
<p><img alt="" height="282" src="https://img-blog.csdnimg.cn/direct/7ad2347663e949f0bd51dbeb8c41d5d7.png" width="340" /></p> 
<p>但是&#xff0c;此时不符合用例1要求&#xff0c;因为step只需要填到n即可&#xff0c;而用例1的n&#61;9&#xff0c;因此填值过程中&#xff0c;我们需要增加一个判断&#xff0c;即step &gt; n时彻底停止添值&#xff0c;即到下面状态时停止。</p> 
<p></p> 
<p><img alt="" height="295" src="https://img-blog.csdnimg.cn/direct/88062ea7af174bf9a2ea5344a9248d68.png" width="307" /></p> 
<p>假设用例1修改为&#xff1a;</p> 
<blockquote> 
 <p>11 4</p> 
</blockquote> 
<p>那么下面状态也是不对的</p> 
<p><img alt="" height="282" src="https://img-blog.csdnimg.cn/direct/7ad2347663e949f0bd51dbeb8c41d5d7.png" width="340" /></p> 
<p>因为11覆盖掉了该位置添的值1&#xff0c;</p> 
<p>因此填值过程如果发现&#xff0c;要添值位置已经有值了&#xff0c;比如下图X--后&#xff0c;发现(X,Y)位置已经填过值了&#xff0c;此时我们应该结束当前方向的添值</p> 
<p><img alt="" height="315" src="https://img-blog.csdnimg.cn/direct/f065b0fba12241f3bcf5f4b1a288a4a7.png" width="361" /></p> 
<p>按照螺旋顺序&#xff0c;下一个添值位置应该如下图所示&#xff1a;</p> 
<p><img alt="" height="308" src="https://img-blog.csdnimg.cn/direct/9aefafe7de36439bb7b45453d5358e6a.png" width="317" /></p> 
<p></p> 
<p>此时应该基于前一个状态进行X&#43;&#43;&#xff0c;Y&#43;&#43;&#xff0c;到达上图黄色位置后&#xff0c;此时又回到螺旋顺序的第一步&#xff0c;从第X行开始正序填入。</p> 
<p></p> 
<h4 id="%E7%AE%97%E6%B3%95%E6%BA%90%E7%A0%81">JS算法源码</h4> 
<pre><code class="language-javascript">const rl &#61; require(&#34;readline&#34;).createInterface({ input: process.stdin });
var iter &#61; rl[Symbol.asyncIterator]();
const readline &#61; async () &#61;&gt; (await iter.next()).value;

void (async function () {
  // n 表示需要在螺旋矩阵中填入 1 ~ n 数字
  // m 是螺旋矩阵行数
  const [n, m] &#61; (await readline()).split(&#34; &#34;).map(Number);

  // k 是螺旋矩阵列数
  const k &#61; Math.ceil(n / m);

  // 螺旋矩阵&#xff0c;未填值位置默认值&#34;*&#34;
  const matrix &#61; new Array(m).fill(0).map(() &#61;&gt; new Array(k).fill(&#34;*&#34;));

  // 当前要填入的值
  let step &#61; 1;

  // 当前要填入的值的位置
  let x &#61; 0;
  let y &#61; 0;

  // 如果填入的值 &gt; n&#xff0c;则停止填值&#xff0c;否则继续填
  while (step &lt;&#61; n) {
    // 正序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
    while (y &lt; k &amp;&amp; matrix[x][y] &#61;&#61; &#34;*&#34; &amp;&amp; step &lt;&#61; n) matrix[x][y&#43;&#43;] &#61; step&#43;&#43;;
    // 正序填完第x行后&#xff0c;y处于末尾越界位置&#xff0c;因此y需要退一步
    y -&#61; 1;
    // 正序填完第x行来到第x行的末尾&#xff0c;即第y列&#xff0c;按照螺旋矩阵顺序&#xff0c;应该从第x&#43;1行开始正序填值第y列
    x &#43;&#61; 1;

    // 正序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
    while (x &lt; m &amp;&amp; matrix[x][y] &#61;&#61; &#34;*&#34; &amp;&amp; step &lt;&#61; n) matrix[x&#43;&#43;][y] &#61; step&#43;&#43;;
    x -&#61; 1;
    y -&#61; 1;

    // 倒序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
    while (y &gt;&#61; 0 &amp;&amp; matrix[x][y] &#61;&#61; &#34;*&#34; &amp;&amp; step &lt;&#61; n) matrix[x][y--] &#61; step&#43;&#43;;
    y &#43;&#61; 1;
    x -&#61; 1;

    // 倒序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
    while (x &gt;&#61; 0 &amp;&amp; matrix[x][y] &#61;&#61; &#34;*&#34; &amp;&amp; step &lt;&#61; n) matrix[x--][y] &#61; step&#43;&#43;;
    x &#43;&#61; 1;
    y &#43;&#61; 1;
  }

  // 打印螺旋矩阵字符串
  for (let i &#61; 0; i &lt; m; i&#43;&#43;) {
    console.log(matrix[i].join(&#34; &#34;));
  }
})();
</code></pre> 
<p></p> 
<h4>Java算法源码</h4> 
<pre><code class="language-java">import java.util.Scanner;
import java.util.StringJoiner;

public class Main {

  public static void main(String[] args) {
    Scanner sc &#61; new Scanner(System.in);

    // 需要在螺旋矩阵中填入 1 ~ n 数字
    int n &#61; sc.nextInt();

    // 螺旋矩阵行数
    int m &#61; sc.nextInt();

    // 螺旋矩阵列数
    int k &#61; (int) Math.ceil(n * 1.0 / m);

    // 螺旋矩阵
    int[][] matrix &#61; new int[m][k]; // 由于需要填入1~n数字&#xff0c;因此这里未填值的位置值默认初始化为0

    // 当前要填入的值
    int step &#61; 1;

    // 当前要填入的值的位置
    int x &#61; 0;
    int y &#61; 0;

    // 如果填入的值 &gt; n&#xff0c;则停止填值&#xff0c;否则继续填
    while (step &lt;&#61; n) {
      // 正序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
      while (y &lt; k &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x][y&#43;&#43;] &#61; step&#43;&#43;;
      // 正序填完第x行后&#xff0c;y处于末尾越界位置&#xff0c;因此y需要退一步
      y -&#61; 1;
      // 正序填完第x行来到第x行的末尾&#xff0c;即第y列&#xff0c;按照螺旋矩阵顺序&#xff0c;应该从第x&#43;1行开始正序填值第y列
      x &#43;&#61; 1;

      // 正序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
      while (x &lt; m &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x&#43;&#43;][y] &#61; step&#43;&#43;;
      x -&#61; 1;
      y -&#61; 1;

      // 倒序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
      while (y &gt;&#61; 0 &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x][y--] &#61; step&#43;&#43;;
      y &#43;&#61; 1;
      x -&#61; 1;

      // 倒序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
      while (x &gt;&#61; 0 &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x--][y] &#61; step&#43;&#43;;
      x &#43;&#61; 1;
      y &#43;&#61; 1;
    }

    // 打印螺旋矩阵字符串
    for (int i &#61; 0; i &lt; m; i&#43;&#43;) {
      StringJoiner row &#61; new StringJoiner(&#34; &#34;);
      for (int j &#61; 0; j &lt; k; j&#43;&#43;) {
        if (matrix[i][j] &#61;&#61; 0) {
          row.add(&#34;*&#34;);
        } else {
          row.add(matrix[i][j] &#43; &#34;&#34;);
        }
      }
      System.out.println(row);
    }
  }
}
</code></pre> 
<p></p> 
<h4>Python算法源码</h4> 
<pre><code class="language-python">import math

# 输入获取
# n 表示需要在螺旋矩阵中填入 1 ~ n 数字
# m 表示螺旋矩阵行数
n, m &#61; map(int, input().split())


# 算法入口
def getResult():
    # k是螺旋矩阵列数
    k &#61; int(math.ceil(n / m))

    # 螺旋矩阵
    matrix &#61; [[&#39;*&#39;] * k for _ in range(m)]  # 未填值位置默认初始化为*

    # 当前要填入的值
    step &#61; 1

    # 当前要填入的值的位置
    x &#61; 0
    y &#61; 0

    # 如果填入的值 &gt; n&#xff0c;则停止填值&#xff0c;否则继续填
    while step &lt;&#61; n:
        # 正序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while y &lt; k and matrix[x][y] &#61;&#61; &#39;*&#39; and step &lt;&#61; n:
            matrix[x][y] &#61; str(step)
            step &#43;&#61; 1
            y &#43;&#61; 1

        # 正序填完第x行后&#xff0c;y处于末尾越界位置&#xff0c;因此y需要退一步
        y -&#61; 1
        # 正序填完第x行来到第x行的末尾&#xff0c;即第y列&#xff0c;按照螺旋矩阵顺序&#xff0c;应该从第x&#43;1行开始正序填值第y列
        x &#43;&#61; 1

        # 正序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while x &lt; m and matrix[x][y] &#61;&#61; &#39;*&#39; and step &lt;&#61; n:
            matrix[x][y] &#61; str(step)
            step &#43;&#61; 1
            x &#43;&#61; 1

        x -&#61; 1
        y -&#61; 1

        # 倒序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while y &gt;&#61; 0 and matrix[x][y] &#61;&#61; &#39;*&#39; and step &lt;&#61; n:
            matrix[x][y] &#61; str(step)
            step &#43;&#61; 1
            y -&#61; 1

        y &#43;&#61; 1
        x -&#61; 1

        # 倒序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while x &gt;&#61; 0 and matrix[x][y] &#61;&#61; &#39;*&#39; and step &lt;&#61; n:
            matrix[x][y] &#61; str(step)
            step &#43;&#61; 1
            x -&#61; 1

        x &#43;&#61; 1
        y &#43;&#61; 1

    # 打印螺旋矩阵字符串
    for i in range(m):
        print(&#34; &#34;.join(matrix[i]))


# 算法调用
getResult()
</code></pre> 
<p></p> 
<h4>C算法源码</h4> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    // n 表示需要在螺旋矩阵中填入 1 ~ n 数字
    // m 表示螺旋矩阵行数
    int n, m;
    scanf(&#34;%d %d&#34;, &amp;n, &amp;m);

    // k 表示螺旋矩阵列数
    int k &#61; (int) ceil(n * 1.0 / m);

    // 螺旋矩阵
    int matrix[m][k];
    for (int i &#61; 0; i &lt; m; i&#43;&#43;) {
        for (int j &#61; 0; j &lt; k; j&#43;&#43;) {
            matrix[i][j] &#61; 0; // 由于需要填入1~n数字&#xff0c;因此这里未填值的位置值默认初始化为0
        }
    }

    // 当前要填入的值
    int step &#61; 1;

    // 当前要填入的值的位置
    int x &#61; 0;
    int y &#61; 0;

    // 如果填入的值 &gt; n&#xff0c;则停止填值&#xff0c;否则继续填
    while (step &lt;&#61; n) {
        // 正序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while (y &lt; k &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x][y&#43;&#43;] &#61; step&#43;&#43;;
        // 正序填完第x行后&#xff0c;y处于末尾越界位置&#xff0c;因此y需要退一步
        y -&#61; 1;
        // 正序填完第x行来到第x行的末尾&#xff0c;即第y列&#xff0c;按照螺旋矩阵顺序&#xff0c;应该从第x&#43;1行开始正序填值第y列
        x &#43;&#61; 1;

        // 正序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号增加&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while (x &lt; m &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x&#43;&#43;][y] &#61; step&#43;&#43;;
        x -&#61; 1;
        y -&#61; 1;

        // 倒序填入第x行&#xff0c;即&#xff1a;行号不变&#xff0c;列号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while (y &gt;&#61; 0 &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x][y--] &#61; step&#43;&#43;;
        y &#43;&#61; 1;
        x -&#61; 1;

        // 倒序填入第y列&#xff0c;即&#xff1a;列号不变&#xff0c;行号减少&#xff0c;注意&#xff1a;添值过程不能发生覆盖&#xff0c;也不能填入超过n的值
        while (x &gt;&#61; 0 &amp;&amp; matrix[x][y] &#61;&#61; 0 &amp;&amp; step &lt;&#61; n) matrix[x--][y] &#61; step&#43;&#43;;
        x &#43;&#61; 1;
        y &#43;&#61; 1;
    }

    // 打印螺旋矩阵字符串
    for (int i &#61; 0; i &lt; m; i&#43;&#43;) {
        for (int j &#61; 0; j &lt; k; j&#43;&#43;) {
            if (matrix[i][j] &#61;&#61; 0) {
                printf(&#34;*&#34;);
            } else {
                printf(&#34;%d&#34;, matrix[i][j]);
            }

            if (j &lt; k - 1) {
                printf(&#34; &#34;);
            }
        }
        puts(&#34;&#34;);
    }

    return 0;
}</code></pre> 
<p></p>
                </div>
        </div>
        <div id="treeSkill"></div>
        <div id="blogExtensionBox" style="width:400px;margin:auto;margin-top:12px" class="blog-extension-box"></div>
    <script>
  $(function() {
    setTimeout(function () {
      var mathcodeList = document.querySelectorAll('.htmledit_views img.mathcode');
      if (mathcodeList.length > 0) {
        for (let i = 0; i < mathcodeList.length; i++) {
          if (mathcodeList[i].naturalWidth === 0 || mathcodeList[i].naturalHeight === 0) {
            var alt = mathcodeList[i].alt;
            alt = '\\(' + alt + '\\)';
            var curSpan = $('<span class="img-codecogs"></span>');
            curSpan.text(alt);
            $(mathcodeList[i]).before(curSpan);
            $(mathcodeList[i]).remove();
          }
        }
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
      }
    }, 1000)
  });
</script>
</div></html>